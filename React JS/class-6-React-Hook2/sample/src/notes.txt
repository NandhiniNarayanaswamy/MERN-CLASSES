1. Normally in JavaScript
__________________________
A function is just like an object â†’ every time you create it, itâ€™s a new one.
------------------------------------------------------------------------
Example:

function sayHello() {
  console.log("Hello")
}

function sayHello() {
  console.log("Hello")
}
-------------------------------------------------------------------------

Even though they â€œlookâ€ the same, these are two different function objects in memory.

problem:- if we click one component all the component in the parent is running and showing, it should happen like this
solution: memo -- In React, memo is a higher-order component (HOC) that is used to optimize performance by preventing unnecessary re-renders of a component.
ğŸ”¹ What happens normally?
When the parent component re-renders, all of its child components also re-render, even if their props havenâ€™t changed.
This can be wasteful and affect performance if the child is heavy (complex UI, expensive calculations, etc.).
ğŸ”¹ What memo does

memo tells React:
ğŸ‘‰ â€œOnly re-render this component if its props actually changed.â€
---------------------------------------------------------------------------------------
ğŸ”¹ How memo actually works
React.memo(Component) tells React: â€œonly re-render this component if its props change.â€
But thereâ€™s a catch:
If a prop is a function, it is recreated on every render of the parent.
That means from the childâ€™s perspective, handleage and handleCount are new props every time, even though their logic didnâ€™t change.
So memo sees different props and forces a re-render.
-------------------------------------------------------------------------------------------------------------------------
Usecallback
***********
âœ…1. Normally in JavaScript

A function is just like an object â†’ every time you create it, itâ€™s a new one.
-------------------------------------------------
Example:

function sayHello() {
  console.log("Hello")
}

function sayHello() {
  console.log("Hello")
}
---------------------------------------------------
Even though they â€œlookâ€ the same, these are two different function objects in memory.

âœ…2. In React

When your component re-renders, React runs the function body again.
That means all functions inside are recreated every render.
------------------------------------------------------------------
function App() {
  const [count, setCount] = useState(0)

  const handleClick = () => setCount(count + 1)

  return <button onClick={handleClick}>+</button>
}
---------------------------------------------------------------------

First render â†’ React creates a handleClick function

Second render â†’ React creates a new handleClick

Third render â†’ another new handleClick

So React is not reusing the old function.

âœ…3. Why is this a problem?

If you pass that function to a child:

<Child onClick={handleClick} />


The child sees a new function prop every time â†’ it re-renders, even if the function body didnâ€™t change.

âœ…4. What useCallback does

useCallback tells React:
ğŸ‘‰ â€œPlease remember this function. Unless something in the dependency array changes, give me back the same exact function next time.â€

const handleClick = useCallback(() => {
  setCount(c => c + 1)
}, [])


Now:

First render â†’ React creates handleClick and saves it.

Next render â†’ React checks dependencies ([] is empty, so nothing changed) â†’ instead of creating a new function, it reuses the saved one.

So the function reference stays the same between renders.

âœ…5. In plain words

Without useCallback:
"Hereâ€™s a new pen every time you write." âœï¸âœï¸âœï¸

With useCallback:
"Hereâ€™s the same pen unless you ask for a new one." ğŸ–Šï¸